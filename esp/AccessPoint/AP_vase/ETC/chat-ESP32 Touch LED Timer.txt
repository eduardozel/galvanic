### USER
touch кнопка TTP223
ESP32-C3  ESP-IDF
TTP223 какой режим?
при старте считывать из файла максимальное время свечения LED
при касании включать led
светить не дольше этого времени
по касании кнопки если время еще не истекло выключать свечение
длительность свечения записывать в файл
при следующем касании включать led на оставшееся время

### ASSISTANT
Ниже я предоставлю полный ответ на ваш запрос на основе анализа. Я использую ESP-IDF для ESP32-C3, сенсорную кнопку TTP223, и реализую логику, которую вы описали. Я интерпретировал вашу логику как паузируемый таймер для LED с сохранением оставшегося времени через restarts (с использованием файла для персистентности). Это включает:

- Чтение "максимального времени свечения" из файла при старте.
- Включение/выключение LED по касанию с ограничением по времени.
- Запись длительности свечения (elapsed time) в файл при выключении (или таймауте).
- При следующем касании — включение на оставшееся время (remaining = max_time - total_used, где total_used — сумма всех предыдущих длительностей из файла).

Если интерпретация неверна, уточните — логика кажется немного неоднозначной, но это наиболее coherent вариант, который соответствует всем пунктам (включая "оставшееся время" и запись "длительности").

### 1. Режим TTP223
TTP223 — это сенсорный чип с конфигурацией через пины (или джамперы на модуле):
- **TOG** (Toggle): 
  - 0 (ground или open, в зависимости от модуля) — **momentary mode** (выход активен только во время касания).
  - 1 (Vcc) — toggle mode (каждое касание переключает состояние выхода high/low).
- **AHLB** (Active High/Low):
  - 0 (ground) — active low (выход low при активации).
  - 1 (Vcc) — active high (выход high при активации).

**Рекомендуемый режим для вашей логики**: 
- **Momentary mode (TOG = 0), active high (AHLB = 1)**.
  - Почему? В toggle mode чип сам переключает состояние, но нам нужно управлять логикой (таймер, remaining) в коде ESP. В momentary mode выход TTP223 идёт high только во время касания (или короткий пульс при тапе). Мы подключаем выход TTP223 к GPIO ESP как input и детектируем rising edge (начало касания) с помощью прерывания. Каждое касание — событие для toggle в коде (вкл/выкл LED с учётом таймера).
  - Если пользователь держит палец, это считается одним событием (rising edge только в начале).
  - Это позволяет реализовать вашу логику программно, без конфликта с таймером.

- Подключение:
  - Vcc TTP223 — 3.3V от ESP.
  - GND — общий.
  - OUT TTP223 — к GPIO ESP (например, GPIO2) как input.
  - Сенсорный pad — ваша "кнопка".

Если ваш модуль TTP223 имеет джамперы, установите их соответственно (обычно по умолчанию momentary active high). Если нужно toggle mode, скажите — можно адаптировать код.

### 2. Логика реализации
- **Файл**: Используем SPIFFS для хранения. Файл `/spiffs/config.txt` (один файл для простоты).
  - Формат: Первая строка — max_time (в секундах, e.g. 3600 для 1 часа).
  - Последующие строки — каждая длительность свечения (elapsed в секундах) от предыдущих сессий.
  - При старте: Читаем файл, парсим max_time из первой строки, суммируем все остальные строки как total_used, remaining = max_time - total_used.
  - При выключении LED (касанием или таймаутом): Вычисляем elapsed, добавляем в память total_used += elapsed, append строку с elapsed в файл.
- **Если remaining <= 0**: При касании не включаем LED.
- **Таймер**: Используем esp_timer (high-res, one-shot) для отключения по remaining.
- **Время**: Используем esp_timer_get_time() для elapsed (в микросекундах, конвертируем в секунды).
- **LED**: Подключаем к GPIO, e.g. GPIO1.
- **Прерывание**: На rising edge от TTP223 для детекции касания.
- **Проблема restarts**: Если перезапуск во время свечения, elapsed потеряется (нет абсолютного времени). Для простоты игнорируем; если нужно, добавьте SNTP для absolute time или периодическое сохранение.

Если файл не существует, создаём с default max_time = 3600 с.

### 3. Код на ESP-IDF
Создайте проект в ESP-IDF (idf.py create-project), добавьте код в `main/main.c`. Нужно включить компоненты: `spiffs`, `esp_timer`, `driver` (для GPIO).

#### CMakeLists.txt (в main)
```cmake
idf_component_register(SRCS "main.c"
                       INCLUDE_DIRS "."
                       REQUIRES esp_timer driver esp_partition spi_flash vfs)
```

#### main.c
```c
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include "freertos/FreeRTOS.h"
#include "freertos/event_groups.h"
#include "freertos/queue.h"
#include "esp_log.h"
#include "esp_vfs.h"
#include "esp_vfs_spiffs.h"
#include "driver/gpio.h"
#include "esp_timer.h"

static const char *TAG = "TTP223_LED";
#define TOUCH_GPIO GPIO_NUM_2  // GPIO для OUT TTP223
#define LED_GPIO GPIO_NUM_1    // GPIO для LED
#define DEFAULT_MAX_TIME 3600  // Default max_time если файл пуст (секунды)
#define FILE_PATH "/spiffs/config.txt"

static QueueHandle_t touch_queue;  // Очередь для прерываний
static bool led_on = false;
static int64_t start_time_us = 0;
static int max_time_s = 0;
static int total_used_s = 0;
static int current_remaining_s = 0;
static esp_timer_handle_t off_timer;

// Callback для таймера (выключение по таймауту)
static void timer_callback(void* arg) {
    gpio_set_level(LED_GPIO, 0);
    led_on = false;
    int64_t now_us = esp_timer_get_time();
    int elapsed_s = (now_us - start_time_us) / 1000000;
    total_used_s += elapsed_s;
    ESP_LOGI(TAG, "Timer expired. Elapsed: %d s, total_used: %d s", elapsed_s, total_used_s);
    append_duration_to_file(elapsed_s);  // Записываем длительность
}

// Append elapsed в файл
static void append_duration_to_file(int elapsed_s) {
    FILE* f = fopen(FILE_PATH, "a");
    if (f == NULL) {
        ESP_LOGE(TAG, "Failed to open file for append");
        return;
    }
    fprintf(f, "%d\n", elapsed_s);
    fclose(f);
    ESP_LOGI(TAG, "Appended duration %d s to file", elapsed_s);
}

// Чтение файла и расчёт remaining
static void read_config_file(void) {
    FILE* f = fopen(FILE_PATH, "r");
    if (f == NULL) {
        // Создаём файл с default
        f = fopen(FILE_PATH, "w");
        if (f == NULL) {
            ESP_LOGE(TAG, "Failed to create file");
            return;
        }
        fprintf(f, "%d\n", DEFAULT_MAX_TIME);
        fclose(f);
        max_time_s = DEFAULT_MAX_TIME;
        total_used_s = 0;
        ESP_LOGI(TAG, "Created default file with max_time %d s", max_time_s);
        return;
    }

    char line[32];
    bool first_line = true;
    total_used_s = 0;
    while (fgets(line, sizeof(line), f) != NULL) {
        int val = atoi(line);
        if (first_line) {
            max_time_s = val;
            first_line = false;
        } else {
            total_used_s += val;
        }
    }
    fclose(f);
    ESP_LOGI(TAG, "Read max_time: %d s, total_used: %d s", max_time_s, total_used_s);
}

// Обработчик прерывания (касание)
static void IRAM_ATTR touch_isr_handler(void* arg) {
    BaseType_t higher_priority_task_woken = pdFALSE;
    xQueueSendFromISR(touch_queue, NULL, &higher_priority_task_woken);
}

// Задача для обработки касаний
static void touch_task(void* arg) {
    while (1) {
        if (xQueueReceive(touch_queue, NULL, portMAX_DELAY)) {
            ESP_LOGI(TAG, "Touch detected");

            if (!led_on) {
                // Включить LED, если есть оставшееся время
                current_remaining_s = max_time_s - total_used_s;
                if (current_remaining_s <= 0) {
                    ESP_LOGW(TAG, "No remaining time");
                    continue;
                }
                led_on = true;
                gpio_set_level(LED_GPIO, 1);
                start_time_us = esp_timer_get_time();
                // Запустить таймер на current_remaining_s секунд
                esp_timer_start_once(off_timer, (uint64_t)current_remaining_s * 1000000LL);
                ESP_LOGI(TAG, "LED ON for %d s", current_remaining_s);
            } else {
                // Выключить LED
                esp_timer_stop(off_timer);
                gpio_set_level(LED_GPIO, 0);
                led_on = false;
                int64_t now_us = esp_timer_get_time();
                int elapsed_s = (now_us - start_time_us) / 1000000;
                total_used_s += elapsed_s;
                append_duration_to_file(elapsed_s);  // Записываем длительность
                current_remaining_s = max_time_s - total_used_s;
                ESP_LOGI(TAG, "LED OFF. Elapsed: %d s, remaining: %d s", elapsed_s, current_remaining_s);
            }
        }
    }
}

void app_main(void) {
    // Инициализация SPIFFS
    esp_vfs_spiffs_conf_t conf = {
        .base_path = "/spiffs",
        .partition_label = NULL,
        .max_files = 5,
        .format_if_mount_failed = true
    };
    esp_vfs_spiffs_register(&conf);

    // Чтение конфига
    read_config_file();

    // Инициализация GPIO
    gpio_config_t io_conf = {
        .mode = GPIO_MODE_OUTPUT,
        .pin_bit_mask = (1ULL << LED_GPIO)
    };
    gpio_config(&io_conf);
    gpio_set_level(LED_GPIO, 0);

    io_conf.mode = GPIO_MODE_INPUT;
    io_conf.pin_bit_mask = (1ULL << TOUCH_GPIO);
    io_conf.intr_type = GPIO_INTR_POSEDGE;  // Rising edge
    io_conf.pull_down_en = 1;  // Pull-down для стабильности
    gpio_config(&io_conf);
    gpio_install_isr_service(0);
    gpio_isr_handler_add(TOUCH_GPIO, touch_isr_handler, NULL);

    // Очередь и задача
    touch_queue = xQueueCreate(10, 0);
    xTaskCreate(touch_task, "touch_task", 2048, NULL, 10, NULL);

    // Таймер
    const esp_timer_create_args_t timer_args = {
        .callback = &timer_callback,
        .name = "off_timer"
    };
    esp_timer_create(&timer_args, &off_timer);

    ESP_LOGI(TAG, "App started");
}
```

### 4. Как запустить
- `idf.py build flash monitor`.
- Создайте partition для SPIFFS (в menuconfig: Partition Table → Custom, добавьте spiffs partition).
- Файл `/spiffs/config.txt` создастся автоматически с default, или загрузите его заранее через `idf.py spiffs` или esptool.
- Тестируйте: Касание — вкл LED на remaining, повторное — выкл и запись elapsed в файл, таймаут — выкл и запись.

### 5. Замечания
- Время в секундах (измените на ms если нужно).
- Если нужно изменить режим TTP223 на toggle, код можно адаптировать (мониторить уровень вместо rising edge).
- Если файл должен быть другим (e.g. NVS вместо файла), скажите — NVS проще для key-value.
- Если логика не та (e.g. max_time не total, а per session), уточните.

Если вопросы или ошибки, предоставьте логи!