### USER
ws2812 rgb радуга    
esp32-c3 esp-idf  
плавно изменение цвета в порядке радуге и обратно на максимальной яркости 32 ступени  
модель hsv  
оформить как процесс  
предусмотреть две процедуры запуск радуги, останов радуги

### ASSISTANT
Ниже я предоставляю полный пример кода на C для ESP32-C3 с использованием ESP-IDF. Код реализует радужный эффект на WS2812 RGB LED (предполагается один LED для простоты; если у вас цепочка, вы можете адаптировать). 

### Ключевые особенности:
- **Радужный эффект**: Используется модель HSV (Hue от 0 до 360, Saturation=1, Value=1 для максимальной яркости). Цвет изменяется плавно в порядке радуги (вперёд от 0 до 360, затем обратно до 0).
- **32 ступени**: Полный цикл (вперёд) разделён на 32 шага (шаг Hue = 360 / 32 ≈ 11.25 градусов). Аналогично для обратного направления. Это даёт 64 шага на полный цикл (вперёд + назад).
- **Плавность**: Задержка 100 мс между шагами (можно настроить). Изменение цвета плавное благодаря линейному изменению Hue.
- **Максимальная яркость**: V=1 в HSV, что соответствует максимуму в RGB (0-255).
- **Оформление как процесс**: Эффект реализован как задача FreeRTOS (rainbow_task).
- **Процедуры**: `start_rainbow()` для запуска, `stop_rainbow()` для остановки. Задача создаётся при запуске и удаляется при остановке.
- **Управление WS2812**: Используется периферия RMT (Remote Control) ESP32 для генерации сигнала. Порядок байт GRB (как требует WS2812). GPIO для LED — 8 (можно изменить).
- **Конверсия HSV to RGB**: Реализована функция `hsv2rgb()` на основе стандартной формулы.

### Требования:
- ESP-IDF v4.4 или выше.
- В `sdkconfig` включите RMT: `CONFIG_RMT_ISR_IRAM_SAFE=1` (для безопасности в ISR).
- Подключите WS2812 к GPIO 8 (data line). Питание 5V, земля общая.
- Если несколько LED, измените `NUM_LEDS` и адаптируйте `set_color()` для цепочки.

### Код (rainbow.c)
```c
#include <stdio.h>
#include <math.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/rmt_tx.h"
#include "esp_log.h"

#define RMT_LED_STRIP_RESOLUTION_HZ 10000000 // 10MHz resolution, 1 tick = 0.1us (LED strip needs a high resolution)
#define RMT_LED_STRIP_GPIO_NUM      8       // GPIO for WS2812 data
#define NUM_LEDS                    1       // Number of LEDs (1 for simplicity)
#define EXAMPLE_LED_STRIP_LENGTH    (NUM_LEDS * 3) // 3 bytes per LED (GRB)

// Global variables
static TaskHandle_t rainbow_task_handle = NULL;
static bool rainbow_active = false;
static rmt_channel_handle_t led_chan = NULL;
static rmt_encoder_handle_t led_encoder = NULL;

// HSV to RGB conversion
void hsv2rgb(float h, float s, float v, uint8_t *r, uint8_t *g, uint8_t *b) {
    h = fmodf(h, 360.0f); // Wrap hue to 0-360
    float c = v * s;
    float x = c * (1.0f - fabsf(fmodf(h / 60.0f, 2.0f) - 1.0f));
    float m = v - c;

    float rp, gp, bp;
    if (h >= 0 && h < 60) {
        rp = c; gp = x; bp = 0;
    } else if (h >= 60 && h < 120) {
        rp = x; gp = c; bp = 0;
    } else if (h >= 120 && h < 180) {
        rp = 0; gp = c; bp = x;
    } else if (h >= 180 && h < 240) {
        rp = 0; gp = x; bp = c;
    } else if (h >= 240 && h < 300) {
        rp = x; gp = 0; bp = c;
    } else {
        rp = c; gp = 0; bp = x;
    }

    *r = (uint8_t)((rp + m) * 255);
    *g = (uint8_t)((gp + m) * 255);
    *b = (uint8_t)((bp + m) * 255);
}

// Function to set color to WS2812 (GRB order)
void set_color(uint8_t r, uint8_t g, uint8_t b) {
    uint8_t led_strip_pixels[EXAMPLE_LED_STRIP_LENGTH];
    led_strip_pixels[0] = g; // Green
    led_strip_pixels[1] = r; // Red
    led_strip_pixels[2] = b; // Blue

    rmt_transmit_config_t tx_config = {
        .loop_count = 0, // no transfer loop
    };
    rmt_transmit(led_chan, led_encoder, led_strip_pixels, sizeof(led_strip_pixels), &tx_config);
    rmt_tx_wait_all_done(led_chan, portMAX_DELAY);
}

// Rainbow task
static void rainbow_task(void *arg) {
    float hue = 0.0f;
    float step = 360.0f / 32.0f; // 32 steps for full rainbow
    int direction = 1; // 1: forward, -1: backward

    while (rainbow_active) {
        // Calculate RGB from HSV (S=1, V=1 max brightness)
        uint8_t r, g, b;
        hsv2rgb(hue, 1.0f, 1.0f, &r, &g, &b);

        // Set color
        set_color(r, g, b);

        // Update hue
        hue += direction * step;
        if (hue >= 360.0f) {
            hue = 360.0f;
            direction = -1;
        } else if (hue <= 0.0f) {
            hue = 0.0f;
            direction = 1;
        }

        // Delay for smooth transition (100ms per step)
        vTaskDelay(pdMS_TO_TICKS(100));
    }

    // Task cleanup
    vTaskDelete(NULL);
}

// Initialize RMT for WS2812
void init_ws2812(void) {
    if (led_chan != NULL) return; // Already initialized

    rmt_tx_channel_config_t tx_chan_config = {
        .clk_src = RMT_CLK_SRC_DEFAULT, // select source clock
        .gpio_num = RMT_LED_STRIP_GPIO_NUM,
        .mem_block_symbols = 64, // increase the block size can make the LED less flickering
        .resolution_hz = RMT_LED_STRIP_RESOLUTION_HZ,
        .trans_queue_depth = 4, // set the number of transactions that can be pending in the background
    };
    ESP_ERROR_CHECK(rmt_new_tx_channel(&tx_chan_config, &led_chan));

    led_strip_encoder_config_t encoder_config = {
        .resolution = RMT_LED_STRIP_RESOLUTION_HZ,
    };
    ESP_ERROR_CHECK(rmt_new_led_strip_encoder(&encoder_config, &led_encoder));

    ESP_ERROR_CHECK(rmt_enable(led_chan));
}

// Start rainbow effect
void start_rainbow(void) {
    if (rainbow_active) return; // Already running

    init_ws2812(); // Ensure initialized

    rainbow_active = true;
    xTaskCreate(rainbow_task, "rainbow_task", 2048, NULL, 5, &rainbow_task_handle);
}

// Stop rainbow effect
void stop_rainbow(void) {
    if (!rainbow_active) return;

    rainbow_active = false;
    if (rainbow_task_handle != NULL) {
        vTaskDelay(pdMS_TO_TICKS(200)); // Wait a bit for task to exit loop
        rainbow_task_handle = NULL;
    }

    // Optional: Turn off LED
    set_color(0, 0, 0);
}
```

### Как использовать:
1. **Инициализация**: Вызовите `init_ws2812()` в `app_main()` если нужно, но `start_rainbow()` вызовет её автоматически.
2. **Запуск**: Вызовите `start_rainbow()` для запуска эффекта.
3. **Остановка**: Вызовите `stop_rainbow()` для остановки. LED выключится (цвет чёрный).
4. **app_main() пример**:
```c
void app_main(void) {
    // Your code...
    start_rainbow();
    // Later...
    // stop_rainbow();
}
```

### Примечания:
- **Скорость**: Задержка 100 мс — это ~3.2 секунды на половину цикла (32 шага). Измените в `vTaskDelay` для другой скорости.
- **Несколько LED**: Если `NUM_LEDS > 1`, заполните массив `led_strip_pixels` в `set_color()` циклом (каждый LED получает одинаковый цвет для радуги).
- **Ошибки**: Проверьте логи с `ESP_LOG` для отладки.
- **Яркость**: Если LED слишком яркий, уменьшите V в `hsv2rgb` (например, 0.5).
- **Тестирование**: Компиляция и загрузка через ESP-IDF tools (idf.py build flash monitor).

Если нужно доработать (например, несколько LED, другой GPIO, скорость), дайте знать!